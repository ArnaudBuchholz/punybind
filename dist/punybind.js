!function (t) { "use strict"; const b = t => { t = `try { with (__context__) { return ${t} } } catch (e) { return '' }`; try { return new Function(`return function(__context__) { ${t} }`)() } catch (t) { } }, g = t => { t = t.split(/{{((?:[^}])+)}}/); if (1 < t.length) return b(`[${t.map((t, e) => e % 2 ? t : `\`${t}\``).join(",")}].join('')`) }, _ = (t, e) => t.getAttribute(e), C = (r, i, t) => { const s = g(_(r, i)); if (s) { let o; t.push((t, e) => { const n = s(t); n !== o && (o = n, e.push(() => { r.setAttribute(i, n) })) }) } }, N = "{{for}}", x = 0, j = 1, A = (t, e) => { var n = t.parentNode, o = t.ownerDocument.createElement("template"); return n.insertBefore(o, t), o.appendChild(t), t.removeAttribute(e), [n, o] }, P = (t, e) => { const n = t.firstChild.cloneNode(!0); return e.push(function () { t.parentNode.insertBefore(n, t) }), [n, f(n)] }, T = "{{if}}", f = t => { const v = [], m = t => { if (3 === t.nodeType) { var r = t; var e = v; const s = g(r.nodeValue); if (s) { const c = r.parentNode; let o; e.push((t, e) => { t = s(t); if (t !== o) { const n = c.ownerDocument.createTextNode(t); o = t, e.push(() => { c.replaceChild(n, r), r = n }) } }) } } if (1 === t.nodeType) if (_(t, N)) { var e = t, o = v, i = _(e, N); if (i = /^\s*(\w+)(?:\s*,\s*(\w+))?\s+of\s(.*)/.exec(i)) { const [, a, u, n] = i, f = b(n); if (f) { const [l, h] = A(e, N), d = []; o.push(async (t, e) => { let n = -1; for await (const o of f(t)) ++n === d.length && d.push(P(h, e)), await $(d[n][j], { ...t, [a]: o, [u]: n }, e); ++n, e.push(function () { this.forEach(t => l.removeChild(t[x])) }.bind(d.slice(n))), d.length = n }) } } } else if (_(t, T)) { i = t, o = v; const p = b(_(i, T)); if (p) { const [w, y] = A(i, T); let n; o.push(async (t, e) => { p(t) ? (n = n || P(y, e), await $(n[j], t, e)) : n && (e.push(function () { w.removeChild(this[x]) }.bind(n)), n = void 0) }) } } else { for (const _ of t.attributes) C(t, _.name, v); Array.prototype.slice.call(t.childNodes).forEach(m) } }; return m(t), v }, $ = async (t, e, n) => { for (const o of t) await o(e, n) }, l = (t, o) => new Proxy(t, { get(t, e) { t = t[e]; return "object" == typeof t ? l(t, o) : t }, set(t, e, n) { return t[e] !== n && (t[e] = n, o()), !0 } }); t.punybind = async (t, e = {}) => { const n = f(t); let o = Promise.resolve(), r, i, s; const c = async () => { try { var t = []; await $(n, s, t); for (const e of t) await e(); s = void 0, r(t.length) } catch (t) { i(t) } }, a = async t => (void 0 === s && (setTimeout(c, 0), o = new Promise((t, e) => { r = t, i = e })), s = t, o); await a(e); var t = l(e, () => { a(e) }), u = t => ({ value: t, writable: !1 }); return Object.defineProperties(a, { bindingsCount: u(n.length), model: u(t), done: u(() => o) }), a } }((0, eval)("this"));